rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ================= DEFAULT DENY =================
    match /{document=**} {
      allow read, write: if false;
    }

    // ================= USERS =================
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return isSignedIn() && request.auth.uid == userId;
      }

      function followersBefore() {
        return resource.data.followers is list
          ? resource.data.followers
          : [];
      }

      function followersAfter() {
        return request.resource.data.followers is list
          ? request.resource.data.followers
          : [];
      }

      function isAddSelfFollower() {
        return !(request.auth.uid in followersBefore())
          && request.auth.uid in followersAfter()
          && followersAfter().size() == followersBefore().size() + 1;
      }

      function isRemoveSelfFollower() {
        return request.auth.uid in followersBefore()
          && !(request.auth.uid in followersAfter())
          && followersAfter().size() + 1 == followersBefore().size();
      }

      function isFollowersOnlyUpdate() {
        return request.auth != null
          && request.resource.data.diff(resource.data).changedKeys()
            .hasOnly(["followers"])
          && (isAddSelfFollower() || isRemoveSelfFollower());
      }

      function isRatingOnlyUpdate() {
        let oldTotal = resource.data.totalChatRatings is int
          ? resource.data.totalChatRatings
          : (resource.data.totalChatRatings is number
            ? resource.data.totalChatRatings
            : 0);

        return request.auth != null
          && request.resource.data.diff(resource.data).changedKeys()
            .hasOnly(["avgChatRating", "totalChatRatings"])
          && request.resource.data.totalChatRatings is number
          && request.resource.data.totalChatRatings == oldTotal + 1
          && request.resource.data.avgChatRating is number
          && request.resource.data.avgChatRating >= 0
          && request.resource.data.avgChatRating <= 5;
      }

      function isReportOnlyUpdate() {
        let oldTotal = resource.data.totalReports is int
          ? resource.data.totalReports
          : (resource.data.totalReports is number
            ? resource.data.totalReports
            : 0);

        return request.auth != null
          && request.resource.data.diff(resource.data).changedKeys()
            .hasOnly(["totalReports"])
          && request.resource.data.totalReports is number
          && request.resource.data.totalReports == oldTotal + 1;
      }

      allow read: if isSignedIn();
      allow create: if isOwner();
      allow update: if isOwner()
        || isFollowersOnlyUpdate()
        || isRatingOnlyUpdate()
        || isReportOnlyUpdate();
      allow delete: if false;
      
      match /devices/{deviceId} {

        // ðŸ‘€ READ PUBLIC KEY (cho E2EE)
        allow read: if request.auth != null;

        // âž• CREATE DEVICE (chá»‰ chá»§ user)
        allow create: if request.auth != null
          && request.auth.uid == userId
          && request.resource.data.keys().hasOnly([
            "publicKey",
            "algorithm",
            "platform",
            "createdAt",
            "lastActiveAt"
          ])
          && request.resource.data.publicKey is string
          && request.resource.data.algorithm == "RSA-2048";

        // âœï¸ UPDATE
        // - CHá»ˆ cho update lastActiveAt
        allow update: if request.auth != null
          && request.auth.uid == userId
          && request.resource.data.diff(resource.data).changedKeys()
              .hasOnly(["lastActiveAt"]);

        // ðŸ—‘ï¸ DELETE DEVICE (revoke)
        allow delete: if request.auth != null
          && request.auth.uid == userId;
      }

    }

    match /users/{userId}/security/backup {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    match /users/{userId}/sessionKeyBackups/{roomId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    match /users/{userId}/sessionKeyBackups/{roomId}/keys/{keyId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // ================= TEMP CHAT ROOM =================
    match /tempChats/{roomId} {

      function isParticipant() {
        return request.auth != null
          && request.auth.uid in resource.data.participants;
      }

      function isValidMinigame() {
        return request.resource.data.minigame is map
          && request.resource.data.minigame.type == "telepathy"
          && request.resource.data.minigame.keys().hasOnly([
            "type",
            "status",
            "invitedAt",
            "consent",
            "cancelledBy",
            "cancelledAt",
            "finishedAt",
            "hookSent",
            "result",
            "questions",
            "answers",
            "currentQuestionIndex",
            "questionStartedAt",
            "startedAt",
            "countdownStartedAt"
          ]);
      }

      function isValidWordChainMinigame() {
        return request.resource.data.minigames is map
          && request.resource.data.minigames.keys().hasOnly(["wordChain"])
          && request.resource.data.minigames.wordChain is map
          && request.resource.data.minigames.wordChain.keys().hasOnly([
            "status",
            "invitedAt",
            "consent",
            "cancelledBy",
            "cancelledAt",
            "startedAt",
            "currentWord",
            "turnUid",
            "remainingSeconds",
            "usedWords",
            "hearts",
            "sosUsed",
            "winnerUid",
            "updatedAt"
          ])
          && request.resource.data.minigames.wordChain.status is string
          && request.resource.data.minigames.wordChain.currentWord is string
          && request.resource.data.minigames.wordChain.turnUid is string
          && request.resource.data.minigames.wordChain.remainingSeconds is number
          && request.resource.data.minigames.wordChain.usedWords is list
          && request.resource.data.minigames.wordChain.hearts is map
          && request.resource.data.minigames.wordChain.sosUsed is map
          && request.resource.data.minigames.wordChain.consent is map
          && (
            !request.resource.data.minigames.wordChain.keys().hasAny(["winnerUid"])
            || request.resource.data.minigames.wordChain.winnerUid is string
          );
      }

      function onlyUpdateMyAvatar() {
        // CÃ¡c field thay Ä‘á»•i
        let changed = request.resource.data.diff(resource.data).changedKeys();

        // Chá»‰ Ä‘Æ°á»£c thay Ä‘á»•i Ä‘Ãºng 1 field
        return changed.size() == 1
          && changed.hasOnly(["anonymousAvatars"])
          && request.resource.data.anonymousAvatars.keys().hasOnly(
            resource.data.anonymousAvatars.keys().union([request.auth.uid])
          )
          && request.resource.data.anonymousAvatars[request.auth.uid]
              == request.resource.data.anonymousAvatars[request.auth.uid];
      }

      // ðŸ‘€ READ temp chat room
      allow read: if request.auth != null;


      // âž• Create room
      allow create: if request.auth != null
        && request.resource.data.participants is list
        && request.auth.uid in request.resource.data.participants;

      // âœï¸ Update
      allow update: if isParticipant()
        && (
          request.resource.data.diff(resource.data).changedKeys()
            .hasOnly([
              "userALiked",
              "userBLiked",
              "typing",
              "status",
              "endedBy",
              "endedReason",
              "permanentRoomId",
              "endedAt",
              "minigame",
              "minigames"
            ])
          && (
            !request.resource.data.diff(resource.data).changedKeys()
              .hasAny(["minigame"])
            || isValidMinigame()
          )
          && (
            !request.resource.data.diff(resource.data).changedKeys()
              .hasAny(["minigames"])
            || isValidWordChainMinigame()
          )
          || (
            request.resource.data.diff(resource.data).changedKeys()
              .hasOnly(["anonymousAvatars"])
            && request.resource.data.anonymousAvatars[request.auth.uid] is string
          )
        );

      allow delete: if false;

      // ================= MESSAGES Temp =================
      match /messages/{messageId} {

        function isRoomParticipant() {
          return request.auth != null
            && request.auth.uid in
              get(/databases/$(database)/documents/tempChats/$(roomId))
                .data.participants;
        }

        allow read: if isRoomParticipant();

        allow create: if isRoomParticipant()
          && get(/databases/$(database)/documents/tempChats/$(roomId))
              .data.status == "active"
          && request.resource.data.senderId == request.auth.uid
          && request.resource.data.createdAt != null;

        allow update: if isRoomParticipant()
          && request.writeFields.size() == 1
          && request.writeFields.hasOnly([
            "reactions." + request.auth.uid
          ]);

        allow delete: if false;
      }
    }

    // ================= CHAT ROOMS =================
    match /chatRooms/{roomId} {

      function isParticipant() {
        return request.auth != null
          && request.auth.uid in resource.data.participants;
      }

      // ðŸ‘€ Ä‘á»c room
      allow read: if isParticipant();

      // âž• táº¡o room (khi convert)
      allow create: if request.auth != null
        && request.resource.data.participants is list
        && request.auth.uid in request.resource.data.participants;

      allow update: if isParticipant()
        && request.resource.data.diff(resource.data).changedKeys()
          .hasOnly([
            "lastMessage",
            "lastMessageType",
            "lastMessageCipher",
            "lastMessageIv",
            "lastMessageKeyId",
            "lastSenderId",
            "lastMessageAt",
            "unread",
            "pinned",
            "deletedFor",
            "typing",
            "currentKeyId",
            "currentKeyUpdatedAt"
          ]);
      
       // ===============================
      // ðŸ” SESSION KEYS (E2EE) - KHÃ”NG ROTATE KEY
      // ===============================
      match /sessionKeys/{deviceId} {

        function isRoomParticipant() {
          return request.auth != null
            && request.auth.uid in
              get(/databases/$(database)/documents/chatRooms/$(roomId))
                .data.participants;
        }

        // âœ… Bá»Ž epoch - chá»‰ cáº§n userId, encryptedKey, createdAt
        allow create, update: if isRoomParticipant()
          && (
            request.resource.data.keys().hasOnly([
              "userId",
              "encryptedKey",
              "createdAt"
            ])
            || request.resource.data.keys().hasOnly([
              "userId",
              "encryptedKey",
              "createdAt",
              "keyId"
            ])
          )
          && request.resource.data.userId is string
          && request.resource.data.encryptedKey is string
          && (
            !("keyId" in request.resource.data)
            || request.resource.data.keyId is int
          );

        // cho phÃ©p participant Ä‘á»c
        allow read: if isRoomParticipant();

        allow delete: if false;
      }

      // ================= MESSAGES Long =================
      match /messages/{messageId} {

        function isRoomParticipant() {
          return request.auth != null
            && request.auth.uid in
              get(/databases/$(database)/documents/chatRooms/$(roomId))
                .data.participants;
        }

        // ðŸ‘€ Ä‘á»c tin nháº¯n
        allow read: if isRoomParticipant();

        // âž• gá»­i / copy tin nháº¯n
        allow create: if isRoomParticipant()
          && request.resource.data.senderId is string
          && request.resource.data.createdAt != null;

        function viewedByMap() {
          return resource.data.viewedBy is map
            ? resource.data.viewedBy
            : {};
        }

        function isViewOnceRecipient() {
          return request.auth.uid != resource.data.senderId;
        }

        function isViewOnceImage() {
          return resource.data.viewOnce == true
            && resource.data.type == "image";
        }

        function isSender() {
          return request.auth.uid == resource.data.senderId;
        }

        allow update: if isRoomParticipant()
          && (
            request.writeFields.size() == 1
            && request.writeFields.hasOnly([
              "reactions." + request.auth.uid
            ])

            || (
              isSender()
              && request.resource.data.senderId == resource.data.senderId
              && request.resource.data.createdAt == resource.data.createdAt
              && (request.resource.data.type == "text"
                  || request.resource.data.type == "deleted")
              && request.resource.data.diff(resource.data).changedKeys()
                .hasOnly([
                  "ciphertext",
                  "iv",
                  "keyId",
                  "type",
                  "editedAt",
                  "editedBy",
                  "deletedAt",
                  "deletedBy"
                ])
            )

            || (
              isViewOnceImage()
              && isViewOnceRecipient()
              && request.resource.data.senderId == resource.data.senderId
              && request.resource.data.viewOnce == true
              && request.resource.data.diff(resource.data).changedKeys()
                .hasOnly([
                  "viewedBy",
                  "type",
                  "text",
                  "imagePath",
                  "imageDeleted",
                  "deletedAt",
                  "deletedBy"
                ])
              && request.resource.data.viewedBy is map
              && request.resource.data.viewedBy.keys().hasOnly(
                viewedByMap().keys().union([request.auth.uid])
              )
            )
          );

      }
    }

  
    match /chatRatings/{id} {

      // ðŸ‘€ Transaction cáº§n read
      allow read: if request.auth != null;

      // âž• Create rating (má»—i user chá»‰ rate tá»« UID cá»§a mÃ¬nh)
      allow create: if request.auth != null
        && request.resource.data.fromUid == request.auth.uid;

      // âŒ KhÃ´ng update / delete
      allow update, delete: if false;
    }
		
    // ================= USER MATCHING REPORT =================
    match /userMatchingReports/{reportId} {

      // âž• Create report
      allow create: if request.auth != null
        && request.resource.data.fromUid == request.auth.uid;

      // âŒ KhÃ´ng cho Ä‘á»c / sá»­a / xÃ³a
      allow read, update, delete: if false;
    }

  }
}

