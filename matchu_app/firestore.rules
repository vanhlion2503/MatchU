rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ================= DEFAULT DENY =================
    match /{document=**} {
      allow read, write: if false;
    }

    // ================= USERS =================
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return isSignedIn() && request.auth.uid == userId;
      }

      function followersBefore() {
        return resource.data.followers is list
          ? resource.data.followers
          : [];
      }

      function followersAfter() {
        return request.resource.data.followers is list
          ? request.resource.data.followers
          : [];
      }

      function isAddSelfFollower() {
        return !(request.auth.uid in followersBefore())
          && request.auth.uid in followersAfter()
          && followersAfter().size() == followersBefore().size() + 1;
      }

      function isRemoveSelfFollower() {
        return request.auth.uid in followersBefore()
          && !(request.auth.uid in followersAfter())
          && followersAfter().size() + 1 == followersBefore().size();
      }

      function isFollowersOnlyUpdate() {
        return request.auth != null
          && request.resource.data.diff(resource.data).changedKeys()
            .hasOnly(["followers"])
          && (isAddSelfFollower() || isRemoveSelfFollower());
      }

      function isRatingOnlyUpdate() {
        let oldTotal = resource.data.totalChatRatings is int
          ? resource.data.totalChatRatings
          : (resource.data.totalChatRatings is number
            ? resource.data.totalChatRatings
            : 0);

        return request.auth != null
          && request.resource.data.diff(resource.data).changedKeys()
            .hasOnly(["avgChatRating", "totalChatRatings"])
          && request.resource.data.totalChatRatings is number
          && request.resource.data.totalChatRatings == oldTotal + 1
          && request.resource.data.avgChatRating is number
          && request.resource.data.avgChatRating >= 0
          && request.resource.data.avgChatRating <= 5;
      }

      function isReportOnlyUpdate() {
        let oldTotal = resource.data.totalReports is int
          ? resource.data.totalReports
          : (resource.data.totalReports is number
            ? resource.data.totalReports
            : 0);

        return request.auth != null
          && request.resource.data.diff(resource.data).changedKeys()
            .hasOnly(["totalReports"])
          && request.resource.data.totalReports is number
          && request.resource.data.totalReports == oldTotal + 1;
      }

      allow read: if isSignedIn();
      allow create: if isOwner();
      allow update: if isOwner()
        || isFollowersOnlyUpdate()
        || isRatingOnlyUpdate()
        || isReportOnlyUpdate();
      allow delete: if false;
      
      match /devices/{deviceId} {

        // ðŸ‘€ READ PUBLIC KEY (cho E2EE)
        allow read: if request.auth != null;

        // âž• CREATE DEVICE (chá»‰ chá»§ user)
        allow create: if request.auth != null
          && request.auth.uid == userId
          && request.resource.data.keys().hasOnly([
            "publicKey",
            "algorithm",
            "platform",
            "createdAt",
            "lastActiveAt"
          ])
          && request.resource.data.publicKey is string
          && request.resource.data.algorithm == "RSA-2048";

        // âœï¸ UPDATE
        // - CHá»ˆ cho update lastActiveAt
        allow update: if request.auth != null
          && request.auth.uid == userId
          && request.resource.data.diff(resource.data).changedKeys()
              .hasOnly(["lastActiveAt"]);

        // ðŸ—‘ï¸ DELETE DEVICE (revoke)
        allow delete: if request.auth != null
          && request.auth.uid == userId;
      }

    }

    match /users/{userId}/security/backup {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    match /users/{userId}/sessionKeyBackups/{roomId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    match /users/{userId}/sessionKeyBackups/{roomId}/keys/{keyId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // ================= TEMP CHAT ROOM =================
    match /tempChats/{roomId} {

      function isParticipant() {
        return request.auth != null
          && request.auth.uid in resource.data.participants;
      }

      function isValidMinigame() {
        return request.resource.data.minigame is map
          && request.resource.data.minigame.type == "telepathy"
          && request.resource.data.minigame.keys().hasOnly([
            "type",
            "status",
            "invitedAt",
            "consent",
            "cancelledBy",
            "cancelledAt",
            "finishedAt",
            "hookSent",
            "result",
            "aiInsight",
            "questions",
            "answers",
            "currentQuestionIndex",
            "questionStartedAt",
            "startedAt",
            "countdownStartedAt"
          ]);
      }

      function isValidWordChainReward() {
        return !request.resource.data.minigames.wordChain.keys()
            .hasAny(["reward"])
          || (
            request.resource.data.minigames.wordChain.reward is map
            && request.resource.data.minigames.wordChain.reward.keys().hasOnly([
              "phase",
              "question",
              "questionPresetId",
              "answer",
              "declineCount",
              "askingStartedAt",
              "answeringStartedAt",
              "askedAt",
              "answeredAt",
              "reviewStartedAt",
              "autoAcceptedReason",
              "completedAt"
            ])
            && request.resource.data.minigames.wordChain.reward.phase is string
            && request.resource.data.minigames.wordChain.reward.declineCount is number
            && (
              request.resource.data.minigames.wordChain.reward.question is string
              || request.resource.data.minigames.wordChain.reward.question == null
            )
            && (
              request.resource.data.minigames.wordChain.reward.questionPresetId is string
              || request.resource.data.minigames.wordChain.reward.questionPresetId == null
            )
            && (
              request.resource.data.minigames.wordChain.reward.answer is string
              || request.resource.data.minigames.wordChain.reward.answer == null
            )
            && (
              request.resource.data.minigames.wordChain.reward.askingStartedAt is timestamp
              || request.resource.data.minigames.wordChain.reward.askingStartedAt == null
            )
            && (
              request.resource.data.minigames.wordChain.reward.answeringStartedAt is timestamp
              || request.resource.data.minigames.wordChain.reward.answeringStartedAt == null
            )
            && (
              request.resource.data.minigames.wordChain.reward.askedAt is timestamp
              || request.resource.data.minigames.wordChain.reward.askedAt == null
            )
            && (
              request.resource.data.minigames.wordChain.reward.answeredAt is timestamp
              || request.resource.data.minigames.wordChain.reward.answeredAt == null
            )
            && (
              request.resource.data.minigames.wordChain.reward.reviewStartedAt is timestamp
              || request.resource.data.minigames.wordChain.reward.reviewStartedAt == null
            )
            && (
              request.resource.data.minigames.wordChain.reward.autoAcceptedReason is string
              || request.resource.data.minigames.wordChain.reward.autoAcceptedReason == null
            )
            && (
              request.resource.data.minigames.wordChain.reward.completedAt is timestamp
              || request.resource.data.minigames.wordChain.reward.completedAt == null
            )
          );
      }

      function isValidWordChainPendingWord() {
        return !request.resource.data.minigames.wordChain.keys()
            .hasAny(["pendingWord"])
          || (
            request.resource.data.minigames.wordChain.pendingWord is map
            && request.resource.data.minigames.wordChain.pendingWord.keys()
              .hasOnly([
                "word",
                "uid",
                "createdAt"
              ])
            && request.resource.data.minigames.wordChain.pendingWord.word is string
            && request.resource.data.minigames.wordChain.pendingWord.uid is string
            && (
              request.resource.data.minigames.wordChain.pendingWord.createdAt is timestamp
              || request.resource.data.minigames.wordChain.pendingWord.createdAt == null
            )
          );
      }

      function isValidWordChainInvalidReason() {
        return !request.resource.data.minigames.wordChain.keys()
            .hasAny(["invalidReason"])
          || request.resource.data.minigames.wordChain.invalidReason is string;
      }

      function isValidWordChainMinigame() {
        return request.resource.data.minigames is map
          && request.resource.data.minigames.keys().hasOnly(["wordChain"])
          && request.resource.data.minigames.wordChain is map
          && request.resource.data.minigames.wordChain.keys().hasOnly([
            "status",
            "invitedAt",
            "countdownStartedAt",
            "consent",
            "cancelledBy",
            "cancelledAt",
            "startedAt",
            "currentWord",
            "turnUid",
            "remainingSeconds",
            "usedWords",
            "hearts",
            "sosUsed",
            "winnerUid",
            "reward",
            "updatedAt",
            "pendingWord",
            "invalidReason"
          ])
          && request.resource.data.minigames.wordChain.status is string
          && request.resource.data.minigames.wordChain.currentWord is string
          && request.resource.data.minigames.wordChain.turnUid is string
          && request.resource.data.minigames.wordChain.remainingSeconds is number
          && request.resource.data.minigames.wordChain.usedWords is list
          && request.resource.data.minigames.wordChain.hearts is map
          && request.resource.data.minigames.wordChain.sosUsed is map
          && request.resource.data.minigames.wordChain.consent is map
          && (
            !request.resource.data.minigames.wordChain.keys().hasAny(["winnerUid"])
            || request.resource.data.minigames.wordChain.winnerUid is string
          )
          && isValidWordChainReward()
          && isValidWordChainPendingWord()
          && isValidWordChainInvalidReason();
      }

      function onlyUpdateMyAvatar() {
        // CÃ¡c field thay Ä‘á»•i
        let changed = request.resource.data.diff(resource.data).changedKeys();

        // Chá»‰ Ä‘Æ°á»£c thay Ä‘á»•i Ä‘Ãºng 1 field
        return changed.size() == 1
          && changed.hasOnly(["anonymousAvatars"])
          && request.resource.data.anonymousAvatars.keys().hasOnly(
            resource.data.anonymousAvatars.keys().union([request.auth.uid])
          )
          && request.resource.data.anonymousAvatars[request.auth.uid]
              == request.resource.data.anonymousAvatars[request.auth.uid];
      }

      // ðŸ‘€ READ temp chat room
      allow read: if request.auth != null;


      // âž• Create room
      allow create: if request.auth != null
        && request.resource.data.participants is list
        && request.auth.uid in request.resource.data.participants;

      // âœï¸ Update
      allow update: if isParticipant()
        && (
          request.resource.data.diff(resource.data).changedKeys()
            .hasOnly([
              "userALiked",
              "userBLiked",
              "typing",
              "status",
              "endedBy",
              "endedReason",
              "permanentRoomId",
              "endedAt",
              "minigame",
              "minigames"
            ])
          && (
            !request.resource.data.diff(resource.data).changedKeys()
              .hasAny(["minigame"])
            || isValidMinigame()
          )
          && (
            !request.resource.data.diff(resource.data).changedKeys()
              .hasAny(["minigames"])
            || isValidWordChainMinigame()
          )
          || (
            request.resource.data.diff(resource.data).changedKeys()
              .hasOnly(["anonymousAvatars"])
            && request.resource.data.anonymousAvatars[request.auth.uid] is string
          )
        );

      allow delete: if false;

      // ================= MESSAGES Temp =================
      match /messages/{messageId} {

        function isRoomParticipant() {
          return request.auth != null
            && request.auth.uid in
              get(/databases/$(database)/documents/tempChats/$(roomId))
                .data.participants;
        }

        function isPendingUserMessageCreate() {
          return (
            !request.resource.data.keys().hasAny(["type"])
            || request.resource.data.type != "system"
          )
          && request.resource.data.text is string
          && request.resource.data.status == "pending"
          && request.resource.data.blockedBy == null
          && request.resource.data.reason == null
          && request.resource.data.warning == false
          && request.resource.data.aiScore == null;
        }

        function isLegacySystemMessageCreate() {
          return request.resource.data.type == "system"
            && request.resource.data.text is string;
        }

        allow read: if isRoomParticipant();

        allow create: if isRoomParticipant()
          && get(/databases/$(database)/documents/tempChats/$(roomId))
              .data.status == "active"
          && request.resource.data.senderId == request.auth.uid
          && request.resource.data.createdAt != null
          && (
            isPendingUserMessageCreate()
            || isLegacySystemMessageCreate()
          );

        allow update: if isRoomParticipant()
          && request.writeFields.size() == 1
          && request.writeFields.hasOnly([
            "reactions." + request.auth.uid
          ]);

        allow delete: if false;
      }
    }

    // ================= CHAT ROOMS =================
    match /chatRooms/{roomId} {

      function isParticipant() {
        return request.auth != null
          && request.auth.uid in resource.data.participants;
      }

      // ðŸ‘€ Ä‘á»c room
      allow read: if isParticipant();

      // âž• táº¡o room (khi convert)
      allow create: if request.auth != null
        && request.resource.data.participants is list
        && request.auth.uid in request.resource.data.participants;

      allow update: if isParticipant()
        && request.resource.data.diff(resource.data).changedKeys()
          .hasOnly([
            "lastMessage",
            "lastMessageType",
            "lastMessageCipher",
            "lastMessageIv",
            "lastMessageKeyId",
            "lastSenderId",
            "lastMessageAt",
            "unread",
            "pinned",
            "deletedFor",
            "typing",
            "currentKeyId",
            "currentKeyUpdatedAt"
          ]);
      
       // ===============================
      // ðŸ” SESSION KEYS (E2EE) - KHÃ”NG ROTATE KEY
      // ===============================
      match /sessionKeys/{deviceId} {

        function isRoomParticipant() {
          return request.auth != null
            && request.auth.uid in
              get(/databases/$(database)/documents/chatRooms/$(roomId))
                .data.participants;
        }

        // âœ… Bá»Ž epoch - chá»‰ cáº§n userId, encryptedKey, createdAt
        allow create, update: if isRoomParticipant()
          && (
            request.resource.data.keys().hasOnly([
              "userId",
              "encryptedKey",
              "createdAt"
            ])
            || request.resource.data.keys().hasOnly([
              "userId",
              "encryptedKey",
              "createdAt",
              "keyId"
            ])
          )
          && request.resource.data.userId is string
          && request.resource.data.encryptedKey is string
          && (
            !("keyId" in request.resource.data)
            || request.resource.data.keyId is int
          );

        // cho phÃ©p participant Ä‘á»c
        allow read: if isRoomParticipant();

        allow delete: if false;
      }

      // ================= MESSAGES Long =================
      match /messages/{messageId} {

        function isRoomParticipant() {
          return request.auth != null
            && request.auth.uid in
              get(/databases/$(database)/documents/chatRooms/$(roomId))
                .data.participants;
        }

        // ðŸ‘€ Ä‘á»c tin nháº¯n
        allow read: if isRoomParticipant();

        // âž• gá»­i / copy tin nháº¯n
        allow create: if isRoomParticipant()
          && request.resource.data.senderId is string
          && request.resource.data.createdAt != null;

        function viewedByMap() {
          return resource.data.viewedBy is map
            ? resource.data.viewedBy
            : {};
        }

        function isViewOnceRecipient() {
          return request.auth.uid != resource.data.senderId;
        }

        function isViewOnceImage() {
          return resource.data.viewOnce == true
            && resource.data.type == "image";
        }

        function isSender() {
          return request.auth.uid == resource.data.senderId;
        }

        allow update: if isRoomParticipant()
          && (
            request.writeFields.size() == 1
            && request.writeFields.hasOnly([
              "reactions." + request.auth.uid
            ])

            || (
              isSender()
              && request.resource.data.senderId == resource.data.senderId
              && request.resource.data.createdAt == resource.data.createdAt
              && (request.resource.data.type == "text"
                  || request.resource.data.type == "deleted")
              && request.resource.data.diff(resource.data).changedKeys()
                .hasOnly([
                  "ciphertext",
                  "iv",
                  "keyId",
                  "type",
                  "editedAt",
                  "editedBy",
                  "deletedAt",
                  "deletedBy"
                ])
            )

            || (
              isViewOnceImage()
              && isViewOnceRecipient()
              && request.resource.data.senderId == resource.data.senderId
              && request.resource.data.viewOnce == true
              && request.resource.data.diff(resource.data).changedKeys()
                .hasOnly([
                  "viewedBy",
                  "type",
                  "text",
                  "imagePath",
                  "imageDeleted",
                  "deletedAt",
                  "deletedBy"
                ])
              && request.resource.data.viewedBy is map
              && request.resource.data.viewedBy.keys().hasOnly(
                viewedByMap().keys().union([request.auth.uid])
              )
            )
          );

      }
    }

  
    // ================= CALL SESSIONS (WEBRTC SIGNALING) =================
    match /callSessions/{callId} {

      function isSignedIn() {
        return request.auth != null;
      }

      function isCallParticipant() {
        return isSignedIn()
          && request.auth.uid in resource.data.participants;
      }

      function isValidCallType(value) {
        return value == "audio" || value == "video";
      }

      function isValidCallStatus(value) {
        return value in ["ringing", "active", "rejected", "ended", "busy", "missed"];
      }

      function roomExistsAndBothAreParticipants() {
        let roomId = request.resource.data.roomChatId;
        return roomId is string
          && exists(/databases/$(database)/documents/chatRooms/$(roomId))
          && request.resource.data.callerId in
            get(/databases/$(database)/documents/chatRooms/$(roomId))
              .data.participants
          && request.resource.data.receiverId in
            get(/databases/$(database)/documents/chatRooms/$(roomId))
              .data.participants;
      }

      function changedKeys() {
        return request.resource.data.diff(resource.data).changedKeys();
      }

      // Read is allowed for caller/receiver.
      // This makes incoming-call query by receiverId/status pass rule checks.
      allow read: if isSignedIn()
        && (
          request.auth.uid == resource.data.callerId
          || request.auth.uid == resource.data.receiverId
          || isCallParticipant()
        );

      // Caller creates the session with initial SDP offer.
      allow create: if isSignedIn()
        && request.resource.data.keys().hasOnly([
          "callId",
          "roomChatId",
          "callerId",
          "receiverId",
          "participants",
          "type",
          "status",
          "offer",
          "answer",
          "createdAt",
          "updatedAt"
        ])
        && request.resource.data.callId == callId
        && request.resource.data.callerId == request.auth.uid
        && request.resource.data.receiverId is string
        && request.resource.data.receiverId != request.auth.uid
        && request.resource.data.participants is list
        && request.resource.data.participants.size() == 2
        && request.resource.data.participants.hasAll([
          request.resource.data.callerId,
          request.resource.data.receiverId
        ])
        && request.resource.data.type is string
        && isValidCallType(request.resource.data.type)
        && request.resource.data.status == "ringing"
        && request.resource.data.offer is map
        && request.resource.data.answer == null
        && roomExistsAndBothAreParticipants();

      // Participants can only update signaling fields.
      allow update: if isCallParticipant()
        && changedKeys().hasOnly([
          "offer",
          "answer",
          "status",
          "updatedAt",
          "answeredAt",
          "endedAt"
        ])
        && request.resource.data.callId == resource.data.callId
        && request.resource.data.roomChatId == resource.data.roomChatId
        && request.resource.data.callerId == resource.data.callerId
        && request.resource.data.receiverId == resource.data.receiverId
        && request.resource.data.participants == resource.data.participants
        && request.resource.data.type == resource.data.type
        && request.resource.data.status is string
        && isValidCallStatus(request.resource.data.status)
        && (
          !changedKeys().hasAny(["offer"])
          || (
            request.auth.uid == resource.data.callerId
            && request.resource.data.offer is map
          )
        )
        && (
          !changedKeys().hasAny(["answer"])
          || (
            request.auth.uid == resource.data.receiverId
            && request.resource.data.answer is map
          )
        );

      allow delete: if false;

      function canReadCandidate() {
        return isSignedIn()
          && exists(/databases/$(database)/documents/callSessions/$(callId))
          && request.auth.uid in
            get(/databases/$(database)/documents/callSessions/$(callId))
              .data.participants;
      }

      function canCreateCandidate() {
        return canReadCandidate()
          && request.resource.data.senderId == request.auth.uid;
      }

      function isValidCandidateDoc() {
        return request.resource.data.keys().hasOnly([
          "candidate",
          "sdpMid",
          "sdpMLineIndex",
          "senderId",
          "createdAt"
        ])
        && request.resource.data.candidate is string
        && (
          request.resource.data.sdpMid == null
          || request.resource.data.sdpMid is string
        )
        && (
          request.resource.data.sdpMLineIndex == null
          || request.resource.data.sdpMLineIndex is int
          || request.resource.data.sdpMLineIndex is number
        );
      }

      match /callerCandidates/{candidateId} {
        allow read: if canReadCandidate();
        allow create: if canCreateCandidate() && isValidCandidateDoc();
        allow update, delete: if false;
      }

      match /calleeCandidates/{candidateId} {
        allow read: if canReadCandidate();
        allow create: if canCreateCandidate() && isValidCandidateDoc();
        allow update, delete: if false;
      }
    }

  
    match /chatRatings/{id} {

      // ðŸ‘€ Transaction cáº§n read
      allow read: if request.auth != null;

      // âž• Create rating (má»—i user chá»‰ rate tá»« UID cá»§a mÃ¬nh)
      allow create: if request.auth != null
        && request.resource.data.fromUid == request.auth.uid;

      // âŒ KhÃ´ng update / delete
      allow update, delete: if false;
    }
		
    // ================= USER MATCHING REPORT =================
    match /userMatchingReports/{reportId} {

      // âž• Create report
      allow create: if request.auth != null
        && request.resource.data.fromUid == request.auth.uid;

      // âŒ KhÃ´ng cho Ä‘á»c / sá»­a / xÃ³a
      allow read, update, delete: if false;
    }

  }
}

