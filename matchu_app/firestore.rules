rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ================= DEFAULT DENY =================
    match /{document=**} {
      allow read, write: if false;
    }

    // ================= USERS =================
    match /users/{userId} {
      allow read, write: if request.auth != null;
      
      match /devices/{deviceId} {

        // üëÄ READ PUBLIC KEY (cho E2EE)
        allow read: if request.auth != null;

        // ‚ûï CREATE DEVICE (ch·ªâ ch·ªß user)
        allow create: if request.auth != null
          && request.auth.uid == userId
          && request.resource.data.keys().hasOnly([
            "publicKey",
            "algorithm",
            "platform",
            "createdAt",
            "lastActiveAt"
          ])
          && request.resource.data.publicKey is string
          && request.resource.data.algorithm == "RSA-2048";

        // ‚úèÔ∏è UPDATE
        // - CH·ªà cho update lastActiveAt
        allow update: if request.auth != null
          && request.auth.uid == userId
          && request.resource.data.diff(resource.data).changedKeys()
              .hasOnly(["lastActiveAt"]);

        // üóëÔ∏è DELETE DEVICE (revoke)
        allow delete: if request.auth != null
          && request.auth.uid == userId;
      }

    }

    match /users/{userId}/security/backup {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    match /users/{userId}/sessionKeyBackups/{roomId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    match /users/{userId}/sessionKeyBackups/{roomId}/keys/{keyId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // ================= TEMP CHAT ROOM =================
    match /tempChats/{roomId} {

      function isParticipant() {
        return request.auth != null
          && request.auth.uid in resource.data.participants;
      }
      
      function onlyUpdateMyAvatar() {
        // C√°c field thay ƒë·ªïi
        let changed = request.resource.data.diff(resource.data).changedKeys();

        // Ch·ªâ ƒë∆∞·ª£c thay ƒë·ªïi ƒë√∫ng 1 field
        return changed.size() == 1
          && changed.hasOnly(["anonymousAvatars"])
          && request.resource.data.anonymousAvatars.keys().hasOnly(
            resource.data.anonymousAvatars.keys().union([request.auth.uid])
          )
          && request.resource.data.anonymousAvatars[request.auth.uid]
              == request.resource.data.anonymousAvatars[request.auth.uid];
      }

      // üëÄ READ temp chat room
      allow read: if request.auth != null;


      // ‚ûï Create room
      allow create: if request.auth != null
        && request.resource.data.participants is list
        && request.auth.uid in request.resource.data.participants;

      // ‚úèÔ∏è Update
      allow update: if isParticipant()
        && (
          // üîπ update c√°c field h·ªá th·ªëng
          request.resource.data.diff(resource.data).changedKeys()
            .hasOnly([
              "userALiked",
              "userBLiked",
              "typing",
              "status",
              "endedBy",
              "endedReason",
              "permanentRoomId",
              "endedAt",
            ])

          // üîπ ho·∫∑c update avatar c·ªßa ch√≠nh m√¨nh
          || (
            request.resource.data.diff(resource.data).changedKeys()
              .hasOnly(["anonymousAvatars"])
            && request.resource.data.anonymousAvatars[request.auth.uid] is string
          )
        );


      allow delete: if false;

      // ================= MESSAGES Temp =================
      match /messages/{messageId} {

        function isRoomParticipant() {
          return request.auth != null
            && request.auth.uid in
              get(/databases/$(database)/documents/tempChats/$(roomId))
                .data.participants;
        }

        allow read: if isRoomParticipant();

        allow create: if isRoomParticipant()
          && get(/databases/$(database)/documents/tempChats/$(roomId))
              .data.status == "active"
          && request.resource.data.senderId == request.auth.uid
          && request.resource.data.createdAt != null;

        allow update: if isRoomParticipant()
          && request.writeFields.size() == 1
          && request.writeFields.hasOnly([
            "reactions." + request.auth.uid
          ]);

        allow delete: if false;
      }
    }

    // ================= CHAT ROOMS =================
    match /chatRooms/{roomId} {

      function isParticipant() {
        return request.auth != null
          && request.auth.uid in resource.data.participants;
      }

      // üëÄ ƒë·ªçc room
      allow read: if isParticipant();

      // ‚ûï t·∫°o room (khi convert)
      allow create: if request.auth != null
        && request.resource.data.participants is list
        && request.auth.uid in request.resource.data.participants;

      allow update: if isParticipant()
        && request.resource.data.diff(resource.data).changedKeys()
          .hasOnly([
            "lastMessage",
            "lastMessageType",
            "lastMessageCipher",
            "lastMessageIv",
            "lastMessageKeyId",
            "lastSenderId",
            "lastMessageAt",
            "unread",
            "pinned",
            "deletedFor",
            "typing",
            "currentKeyId",
            "currentKeyUpdatedAt"
          ]);
      
       // ===============================
      // üîê SESSION KEYS (E2EE) - KH√îNG ROTATE KEY
      // ===============================
      match /sessionKeys/{deviceId} {

        function isRoomParticipant() {
          return request.auth != null
            && request.auth.uid in
              get(/databases/$(database)/documents/chatRooms/$(roomId))
                .data.participants;
        }

        // ‚úÖ B·ªé epoch - ch·ªâ c·∫ßn userId, encryptedKey, createdAt
        allow create, update: if isRoomParticipant()
          && (
            request.resource.data.keys().hasOnly([
              "userId",
              "encryptedKey",
              "createdAt"
            ])
            || request.resource.data.keys().hasOnly([
              "userId",
              "encryptedKey",
              "createdAt",
              "keyId"
            ])
          )
          && request.resource.data.userId is string
          && request.resource.data.encryptedKey is string
          && (
            !("keyId" in request.resource.data)
            || request.resource.data.keyId is int
          );

        // cho ph√©p participant ƒë·ªçc
        allow read: if isRoomParticipant();

        allow delete: if false;
      }

      // ================= MESSAGES Long =================
      match /messages/{messageId} {

        function isRoomParticipant() {
          return request.auth != null
            && request.auth.uid in
              get(/databases/$(database)/documents/chatRooms/$(roomId))
                .data.participants;
        }

        // üëÄ ƒë·ªçc tin nh·∫Øn
        allow read: if isRoomParticipant();

        // ‚ûï g·ª≠i / copy tin nh·∫Øn
        allow create: if isRoomParticipant()
          && request.resource.data.senderId is string
          && request.resource.data.createdAt != null;

        allow update: if isRoomParticipant()
          && request.writeFields.size() == 1
          && request.writeFields.hasOnly([
            "reactions." + request.auth.uid
          ]);

      }
    }

  
    match /chatRatings/{id} {

      // üëÄ Transaction c·∫ßn read
      allow read: if request.auth != null;

      // ‚ûï Create rating (m·ªói user ch·ªâ rate t·ª´ UID c·ªßa m√¨nh)
      allow create: if request.auth != null
        && request.resource.data.fromUid == request.auth.uid;

      // ‚ùå Kh√¥ng update / delete
      allow update, delete: if false;
    }
		
    // ================= USER MATCHING REPORT =================
    match /userMatchingReports/{reportId} {

      // ‚ûï Create report
      allow create: if request.auth != null
        && request.resource.data.fromUid == request.auth.uid;

      // ‚ùå Kh√¥ng cho ƒë·ªçc / s·ª≠a / x√≥a
      allow read, update, delete: if false;
    }

  }
}

